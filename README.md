# pycmdparse
Python command line parser, and usage instructions generator

There are many command-line parse utilities floating around, but I decided to make my own for fun, and to get some experience packaging Python. This particular parser is defined in yaml. It supports parsing args, detecting errors, validating data types, and printing usage instructions. It fits the text of the usage instructions to the console window width unless the yaml includes linefeeds.

This arg parser is used as follows:

1) You're writing a console utility in Python, and you have complex args that need to be parsed, and you want to also display usage instructions in a way that is generally consistent with other console utils
2) You import this package and subclass the `CmdLine` class
3) Initialize the `yaml_def` field in your subclass with a yaml definition of options/params/usage (see below)
4) Call the `parse` function of your subclass to parse the command line. It initializes itself from the yaml, and then tries to parse the command line using the yaml-defined options and params.
5) If successful, the `parse` function injects fields into the subclass - one for each option defined in the yaml spec
6) You then access the injected fields to get the values provided by the user on the command line
7) If there is an error parsing the command line, use the subclass to display errors, or display usage instructions as specified in the yaml

There's a basic example in the `tests` directory.

The yaml "schema" that the class understands is:
```
    program_name: your program name

    summary: >
        free form text summmarizing the utility
    
    # If there is no usage section, then it is generated by pycmdparse
    #usage: >
    #  free form text with abbreviated usage

    positional_params:
      params: a list of the positional params supported, e.g. "FROMFILE TOFILE"
      text: >
        free form text describing that the positional params are
        
    supported_options:
      - category: if empty, then no categorization, else displays an option category
        options:
        - name    : a valid python identifier
          short   : single letter option key
          long    : long option key
          hint    : a hint to tell the user what parameter to provide
          required: true or false
          opt     : option type. One of: bool, param, multi-param
          internal: true or false
          default : a default value
          help: >
            free form text describing the option
        - name    : repeats...
          ...
      - category: repeats
        options:
        - name    : repeats
          ...

    details: >
      More detailed text if needed

    examples:
      - example: how you would run your utility from the command line
        explanation: >
          description of what the result would be in this case

      - example: multiple examples if helpful
        explanation: >
          ...

    addendum: >
      free-form text, for copyright, links, etc.
```
There are three option types: `bool` is for things like `-v`, or `--verbose` that are off by default, and turned on via the presence of the option. `param` is for an option taking one parameter. Like `-f filename`, or `--file-name=foofile`. `multiparam` is an option that takes multiple params. For this, the yaml indicates whether an exact count is needed, or a max number of parameters, or no limit.

### todo...
1. Complete the packaging
2. Add tests
3. Document the yaml schema that the utility supports

